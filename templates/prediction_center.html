{% extends 'base.html' %}
{% block title %}æ”¶ç›Šå›æµ‹ä¸AIé¢„æµ‹{% endblock %}

{% block content %}
<el-row :gutter="20">
    <el-col :span="12">
        <el-card header="ğŸ”® AI è¶‹åŠ¿é¢„æµ‹ (LSTM)">
            <div style="display:flex; gap:10px; margin-bottom:20px">
                <el-input v-model="predictCode" placeholder="è‚¡ç¥¨ä»£ç  (å¦‚ 000001)" prefix-icon="Search"></el-input>
                <el-button type="primary" @click="runPredict" :loading="loadingP">å¼€å§‹é¢„æµ‹</el-button>
            </div>

            <div v-if="predictResult" style="text-align:center">
                <h2 :style="{color: predictResult.suggestion_color}">[[ predictResult.suggestion ]]</h2>
                <p>æœªæ¥5æ—¥é¢„æœŸæ”¶ç›Š: <b :style="{color: predictResult.final_return>0?'red':'green'}">[[ predictResult.final_return ]]%</b></p>
            </div>

            <div id="predict-chart" style="height:350px; width:100%"></div>
        </el-card>
    </el-col>

    <el-col :span="12">
        <el-card header="ğŸ“Š å†å²ç­–ç•¥å›æµ‹ (MAå‡çº¿ç­–ç•¥)">
            <div style="display:flex; gap:10px; margin-bottom:20px">
                <el-input v-model="backtestCode" placeholder="è‚¡ç¥¨ä»£ç  (å¦‚ 600519)" prefix-icon="Search"></el-input>
                <el-button type="success" @click="runBacktest" :loading="loadingB">è¿è¡Œå›æµ‹</el-button>
            </div>

            <div v-if="backtestResult" style="display:flex; justify-content:space-around; text-align:center; margin-bottom:15px; background:#f5f7fa; padding:10px; border-radius:4px">
                <div>
                    <div style="font-size:12px; color:#909399">æ€»æ”¶ç›Šç‡</div>
                    <div style="font-size:18px; font-weight:bold" :style="{color: backtestResult.metrics.total_return>0?'red':'green'}">
                        [[ backtestResult.metrics.total_return ]]%
                    </div>
                </div>
                <div>
                    <div style="font-size:12px; color:#909399">æœ€å¤§å›æ’¤</div>
                    <div style="font-size:18px; font-weight:bold; color:green">[[ backtestResult.metrics.max_drawdown ]]%</div>
                </div>
                <div>
                    <div style="font-size:12px; color:#909399">èƒœç‡</div>
                    <div style="font-size:18px; font-weight:bold; color:#E6A23C">[[ backtestResult.metrics.win_rate ]]%</div>
                </div>
            </div>

            <div id="backtest-chart" style="height:350px; width:100%"></div>
        </el-card>
    </el-col>
</el-row>

<script>
function pageSetup() {
    const activeMenu = ref('3');

    // AI é¢„æµ‹ç›¸å…³
    const predictCode = ref('000001');
    const loadingP = ref(false);
    const predictResult = ref(null);
    let chartP = null;

    // å›æµ‹ç›¸å…³
    const backtestCode = ref('600519');
    const loadingB = ref(false);
    const backtestResult = ref(null);
    let chartB = null;

    // è¿è¡Œ AI é¢„æµ‹
    const runPredict = async () => {
        loadingP.value = true;
        try {
            const res = await axios.post('/api/prediction/run/', { code: predictCode.value });
            if (res.data.code === 200) {
                predictResult.value = res.data.data;
                setTimeout(() => drawPredictChart(res.data.data), 100);
            } else { ElementPlus.ElMessage.error(res.data.msg); }
        } finally { loadingP.value = false; }
    };

    // è¿è¡Œå›æµ‹
    const runBacktest = async () => {
        loadingB.value = true;
        try {
            const res = await axios.post('/api/backtest/run/', { code: backtestCode.value });
            if (res.data.code === 200) {
                backtestResult.value = res.data.data;
                setTimeout(() => drawBacktestChart(res.data.data.chart), 100);
            } else { ElementPlus.ElMessage.error('æ•°æ®ä¸è¶³æˆ–è®¡ç®—å¤±è´¥'); }
        } finally { loadingB.value = false; }
    };

    // ç»˜å›¾: AI é¢„æµ‹
    const drawPredictChart = (data) => {
        if (chartP) chartP.dispose();
        chartP = echarts.init(document.getElementById('predict-chart'));

        const historyData = data.history_prices;
        const futureData = data.future_prices;
        const xData = [...data.history_dates, ...data.future_dates];

        // æ‹¼æ¥æ•°æ®è®©çº¿æ¡è¿è´¯
        const seriesFuture = new Array(historyData.length - 1).fill(null);
        seriesFuture.push(historyData[historyData.length - 1]); // è¿æ¥ç‚¹
        seriesFuture.push(...futureData);

        chartP.setOption({
            tooltip: { trigger: 'axis' },
            legend: { data: ['å†å²', 'é¢„æµ‹'] },
            xAxis: { type: 'category', data: xData },
            yAxis: { scale: true },
            series: [
                { name: 'å†å²', type: 'line', data: historyData, itemStyle: {color: '#333'} },
                { name: 'é¢„æµ‹', type: 'line', data: seriesFuture, itemStyle: {color: '#409EFF'}, lineStyle: {type: 'dashed'} }
            ]
        });
    };

    // ç»˜å›¾: èµ„é‡‘æ›²çº¿
    const drawBacktestChart = (chartData) => {
        if (chartB) chartB.dispose();
        chartB = echarts.init(document.getElementById('backtest-chart'));

        const dates = chartData.map(i => i.date);
        const values = chartData.map(i => i.value);

        chartB.setOption({
            tooltip: { trigger: 'axis' },
            title: { text: 'è´¦æˆ·èµ„é‡‘æ›²çº¿', left: 'center', textStyle: {fontSize: 14} },
            xAxis: { type: 'category', data: dates },
            yAxis: { scale: true },
            series: [{ name: 'æ€»èµ„äº§', type: 'line', data: values, smooth: true, areaStyle: { opacity: 0.1 }, itemStyle: {color: '#F56C6C'} }]
        });
    };

    return { activeMenu, predictCode, loadingP, predictResult, runPredict, backtestCode, loadingB, backtestResult, runBacktest };
}
</script>
{% endblock %}